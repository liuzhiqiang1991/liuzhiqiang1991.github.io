#### 1、lsof指令全称

```
    List Open Files, 列出 Linux 等操作系统中打开的文件。
    lsof -i:8080  查看端口占用情况
```
#### 2、ConcurrentHashMap原理

```
    (1) 存储结构
    ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），
    每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。

    Segment 继承自 ReentrantLock。
    默认的并发级别为 16，也就是说默认创建 16 个 Segment。

    (2). size 操作
    每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。

    在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。
    ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。

    尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。
    如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。

    (3). JDK 1.8 的改动
    JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。

    JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。

    并且 JDK 1.8 的实现也在链表过长时(超过8)会转换为红黑树。
```
#### 3、IOC是什么？AOP是什么？
    AOP（Aspect Oriented Programming），即面向切面编程。作用是简化重复的代码。

#### 4、悲观锁和乐观锁是什么？

```
    悲观锁： 操作系统悲观的认为，如果不严格同步线程调用，那么一定会产生异常。
    所以互斥锁将会将锁定资源，只供一个线程调用，而阻塞其他线程，因此这种同步机制也叫悲观锁。

    乐观锁：通过CAS来实现同步，不会锁定资源，而且当线程需要修改共享资源的对象时，总是会乐观的认为，
    对象状态值没有被其他线程修改过，而是每次自己都会主动尝试去compare状态值。
    本质是一种无锁的同步机制。

    CAS: compare and swap
    自旋：不断重试CAS操作
```


#### 5、synchronized, 锁的4种状态
```
    无锁、偏向锁、轻量级锁、重量级锁

    1、锁存放在对象头中
    2、对象包含3部分：对象头、实例数据、填充字节
    3、对象头包含2部分： Mark Word、Class Pointer（指向方法区对应的数据）
    4、Mark Word只有32bit

    synchronized 编译后会转成monitorenter、monitorexit两个字节码指令
    偏向锁：如果只有一个线程调用，就可以不进行线程切换
    （1）首先根据锁标志位和倒数第3bit，判断是否是偏向锁
    （2）如果是偏向锁，再获取前23bit, 获取线程id。如果线程id和当前线程不一致，就会升级为轻量级锁。
    （3）针对轻量级锁，就会在jvm栈中开辟一块Lock Record的空间。当前线程会记录到Lock Record中，其他线程会自旋等待。
      如果自旋等待的线程超过1个，就会转成重量级锁。
    （4）针对重量级锁，会采用monitor完全锁定资源。
```

#### 6、synchronized 和 ReentrantLock 区别
    ReentrantLock 基于AQS, 在并发编程中它可以实现公平锁和非公平锁来对共享资源进行同步，
    同时和synchronized一样，ReentrantLock支持可重入，此外ReentrantLock在调度上更灵活，支持更多丰富的功能。

#### 7、Redis的持久化机制
```
    (1) RDB (Redis Database):
        在指定时间间隔内，将内存中的数据快照写入磁盘，
        它是某一个时间点上数据的完整副本，可以通过配置文件中的save参数来配置。
        快照文件有个缺点就是，如果服务器在快照之后宕机了，那么最后一次快照之后的所有修改内容都会丢失掉。

    (2) AOF (Appen Only File):
        只追加文件，它的原理是在执行写命令的时候，不仅会将命令写入到内存中，
        还会将命令写入到一个追加的文件中，这个文件就是AOF文件。它会以日志的形式记录每一个写操作。
        当Redis重启的时候，就会通过重新执行AOF文件中的命令，来在内存中重建整个数据库的内容。
```

#### 8 redis主从复制

```
    是指将一台服务器的数据复制到其他redis服务器。主节点负责写操作，从节点负责读操作。
    主节点会将自己的数据变化，通过异步的方式发送给从节点，从节点接受到主节点的数据后，
    更新自己的数据，这样就达到了数据一致的目的。

    port 6380
    pid_file /var/run/redis_6380.conf
    dbfilename dump-6380.rdb
    replicaof 127.0.0.1 6379


    :%s/6380/6381/g
```

#### 9、redis默认端口号： 6379
#### 10、redis哨兵模式

```
    如果没有哨兵模式，那么当主节点宕机，需要手工把另一台从节点提升为主节点，需要人工干预。

    哨兵会以一个独立的进程运行在redis集群中，用来监控redis集群中的各个节点是否运行正常。
    功能：
    （1）监控，通过不断的发送命令，检查redis节点是否正常。
    （2）通知，如果发现某个节点异常，那么哨兵就会通过发布订阅模式，来通知其他节点。
    （3）自动故障转移，当主节点不能正常工作的时候，哨兵会开始一个自动故障转移的操作，
    它会将一个从节点升级为主节点，然后再将其他从节点指向新的主节点。
```

#### 11、索引失效有哪些情况？
```
    1) 查询条件中有or
    2) like查询是以'%'开头

    3）查询列（索引）上有运算或者函数
    4）查询列（索引）类型不对

    5）mysql估计使用全表扫描要比使用索引快
    6）联合索引没有遵循最左匹配原则
```

#### 12、抽象类和接口的区别

```
    抽象类: 对事物的整体进行抽象
    接口：  对事物的某一个行为进行抽象

    1、抽象类中可以定义构造器，接口不行
    2、抽象类中可以有抽象方法和具体方法，接口中全部都是抽象方法
    3、抽象类中可以包含静态方法，接口中不能有静态方法
    4、一个类只能继承一个抽象类，可以实现多个接口
```

<font color="#dd00dd" size=6>JVM</font><br />

#### 1、jvm， 运行时数据区域


<div style="font-size: 18px; font-weight: 500; face: 楷体;">

```

    所有线程共享的: 方法区、堆

    线程独享的: 虚拟机栈、本地方法栈、程序计数器

    程序计数器: 用于指示每个线程执行的命令标识

    本地方法栈保存虚拟机调用local方法保存的临时变量
```

</div>

#### 2、判断对象是否存活？
```
	1）引用计数算法；很难解决对象之间循环引用的问题

	2）可达性分析算法；选择一个起点，开始全图遍历，没有遍历到的数据都是不可达的；
		可以作为起点的对象：
		1）虚拟机栈、本地方法栈引用的对象
		2）方法区中常量、静态变量引用的对象

		对于可达性分析，真正宣告一个对象死亡，要经历至少两次标记过程；
		第一次标记后，会判断是否要执行finalize算法；如果需要执行finalize方法，会被放到一个队列中，但不能保证一定会执行；
		第二次标记后，就会被删除
```

#### 3、垃圾回收算法
```
	1)标记-清除（Mark-Sweep）
		首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象；
		不足：
		1）标记和清除两个效率都不高
		2）会产生大量不连续的内存碎片

	2）复制
		将内存分成两块，其中一块清除之后，所有残余对象被复制到另一块内存，并把当前内存全部清除掉。

	3）标记-整理
		让所有存活的对象对向一端移动，然后直接清理掉端边界以外的内存

	4）分代回收
		将Java对象分成新生代和老年代，根据各年代选择合适的算法。

		新生代中只有少量对象存活，选择复制算法；老年代选择标记清理或者标记整理算法；

	总结：
		新生代内存分成一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一个Survivor；(8:1:1)
		当回收时，将Eden和其中一个Survivor中还存活的对象一次性复制到另一个Survivor空间上，最后清理到Eden和刚才用过的Survivor；
        新生代和老年代默认1:2
```

#### 4、jvm内存参数
```
    -Xms1g  （起始内存）
    -Xmx1g  （最大内存）
```

#### 5、类的加载机制
- 类的生命周期：
```
    加载    连接（验证、准备、解析)    初始化   使用    卸载
    （        类加载 class loading        ）
```

- 加载
```
    a、根据类的全限定名获取类的二进制字节流
    b、将字节流代表的静态存储结构转化为方法区的运行时数据结构
    c、在内存中生成一个Class对象，作为方法区这个类的各种数据的访问入口
```
- 连接
```
    验证： 验证Class文件
          1、符合虚拟机要求
          2、不会危害虚拟机自身的安全
    准备：
          1、分配内存
          2、设置类变量的初始值（零值）
    解析：
          1、将常量池内的符号引用替换为直接引用的过程
```

- 初始化
```
    在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化类变量和其他资源。


```

<br />

#### 6、双亲委派模型
```
    双亲委派模型要求除了顶层的启动类加载器（Bootstrap ClassLoader）外，其余的类加载器都应当有自己的父类加载器。

    这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。

```

#### 双亲委派模型的工作过程
```
    如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，

    每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈

    自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
```

<br/><br/>

#### 7. CMS，G1收集器特点
* 空间整合： 与CMS的标记——清理算法不同，G1从整体上看是基于标记——整理算法实现的收集器，从局部（两个Region之间）上来看是基于复制算法来实现的。 这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。

* G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集器上的时间不得超过N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。

* 在G1之前的其他垃圾收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

<br/><br/>

#### 8. Java内存模型:    Java线程 <————> 工作内存 <————> 主内存

* Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。 主内存可以与硬件中的主内存类比，工作内存可以与处理器高速缓存类比。

* 线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读取主内存中的变量。

* 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

<br/><br/>

#### 9. 当一个变量定义为volatile, 它将具备两种特性：

* 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

* 第二是禁止指令重排序优化

<br/><br/>

#### 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍然要通过加锁来保证原子性。

* 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。

* 变量不需要与其他的状态变量共同参与不变约束。

<br/><br/>

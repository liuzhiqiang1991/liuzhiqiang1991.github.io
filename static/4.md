<font color="#dd00dd" size=6>网络</font><br />

#### 1、HTTP常见状态码
```
    200成功
    400 bad request 错误的请求 （1）语义有误（2）参数有误
    401未登录
    403无权限
    404页面不存在
    405 大部分是 传输的方式不正确，把get改为post或者post改成get
    500服务器内部错误
```
#### 2、Https怎么加密
```
    https://blog.csdn.net/qq_29996285/article/details/84284524

    1、对称加密：私钥和公钥相同
    2、非对称加密：私钥加密，公钥解密
    3、对称加密+非对称加密结合
        用非对称加密的方式去传输对称加密的密钥，这样可以保证对称加密的密钥可以安全的交付给对方。
        1）客户端先把非对称加密的公钥，明文传输给服务器；
        2）服务端在接到密钥之后，会生成一把用于对称加密的密钥；
        3）服务器用之前接到的公钥对刚刚生成的密钥进行加密，然后传输给客户端；
        4）客户端通过自己的密钥对服务器传过来的被公钥加密过的密钥进行解密；
    问题：
        如果在步骤一的时候，公钥被第三方截取，之后客户端与第三方走完了上述的四个步骤，建立了对称加密的传输。
        第三方再和服务器走完上面的四步。如此，第三方拥有了和客户端进行对称传输的密钥，以及和服务器传输的密钥。
        而这个第三方的存在，服务器和客户端都没办法察觉到。

    关键问题就是客户端不知道和自己建立连接的是不是真的目标服务器。那么，我们需要在建立连接的时候，对服务器的身份进行验证。
    这就需要https加密

    数字证书： 我们需要一个大家都认可的认证中心（CA）
    服务器产生数字证书的过程：

        1、服务器在给客户端传送公钥的过程中，会把公钥以及服务器的个人信息通过哈希算法生成信息摘要。
        2、之后服务器利用CA提供的私钥对信息摘要进行加密，来形成数字签名。
        3、将没有经过哈希算法处理的个人信息以及公钥，和数字签名合并在一起，形成数字证书。

    客户端拿到数字证书之后：

        1、就会利用CA提供的公钥对数字证书里面的数字签名进行解密来得到信息摘要
        2、然后对数组证书里面的服务器公钥以及服务器的个人信息进行hash得到另一份信息摘要。
        3、最后把两份信息摘要进行对比，如果一样，则证明是服务器。
    如此，保证服务器的公钥就安全的交给客户端了。

    那么CA向客户端提供的公钥以及向服务器提供的私钥又是从哪来的？（重点）
    服务器需要向认证中心去申请证书，客户端也会内置这些证书。
    当客户端收到服务器传来的数据数字证书时，会在内置的证书列表里，查看是否有解开该数字特征的公钥。
```
#### 3、七层协议，每层协议的作用（OSI, Open System Interconnection, 开放系统互联）
```
    物理层，负责将信息编码成电流脉冲，或其他信号用于网络传输
    数据链路层，定义了在单个链路上如何传输数据
    网络层，对端到端的包传输进行定义（IP）
    传输层，向高层提供可靠的数据流传输服务（TCP、UDP）

    会话层：定义如何开始、控制和结束一个会话
    表示层：用于应用层数据编码与转化，确保一个应用层发送的消息，能够被另一个系统应用层识别
    应用层：与其他计算机信息传输的一个应用
```
#### 4、TCP、UDP特点
```
    TCP特点
    1、TCP有连接（UDP无连接）
    2、提供的是一对一的（UDP支持一对一、一对多、多对一、多对多）

    3、可靠交付（UDP不可靠、尽最大努力交付）
    4、全双工通信（全双工（full-duplex）的系统允许二台设备间同时进行双向数据传输。）

    5、面向字节流（面向数据报）
    6、头部20字节（UDP头部8个字节）
```
#### 5、3次握手、4次挥手
```
    3次握手：（2，4，3）
    （1）客户端——服务端（SYN=1，  seq=x),客户端进入SYN-SENT状态
    （2）服务端——客户端（SYN=1，  seq=y，ACK=1，ack=x+1),服务端进入SYN-RECEIVED状态
    （3）客户端——服务端（         seq=x+1,ACK=1,ack=y+1),客户端发送后进入establish状态，服务端收到后进入establish状态
    3次握手是为了防止失效的消息又传送到了服务端

    4次挥手：（2，3，4，3）
    （1）客户端——服务端（FIN=1,  seq=u),客户端进入FIN-WAIT－1状态
    （2）服务端——客户端（        seq=v,ACK=1,ack=u+1),服务端进入close-wait状态
    （3）服务端——客户端（FIN=1,  seq=w,ACK=1,ack=u+1),服务端结束close-wait,进入Last-ack（等待最后确认）
    （4）客户端——服务端（        seq=u+1,ACK=1,ack=w+1),客户端等待2MSL（2倍最大传输时间，然后close，服务端接收到消息后close）

    为什么要等待2MSL：
    第一，为了保证 客户端 发送的最后一个ACK报文能够到达 服务端。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。
        服务端 会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。
        如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。
        这样，B就无法按照正常的步骤进入CLOSED状态。

    第二，A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。

    MSL不同系统的默认值
    Windows : MSL = 2 min
    linux(Ubuntu, CentOs) : MSL = 60s
    Unix : MSL = 30s
```
#### 6、点击连接后发生的事情：
```
    （1）浏览器分析URL
    （2）浏览器向DNS请求解析IP地址
    （3）DNS解析出IP

    （4）浏览器与服务器建立TCP连接
    （5）浏览器发出请求（比如get）
    （6）服务器响应请求
    （7）释放TCP连接

    （8）浏览器显示结果
```
#### 7、HTTP1.0和HTTP1.1的主要区别
```
    HTTP1.0至少需要文档的传输时间 + 两倍往返时间RTT（一个用于TCP连接，一个用于请求和接收文档）
    HTTP1.1采用持续连接，就是在服务器响应后仍然保持这条连接。
```

#### 8、阐述拥塞控制和滑动窗口，分别是为了解决什么问题？
```
    滑动窗口
    1、发送方的发送速度不要太快，让接收方能够来得及接收
        发送窗口小于接收窗口

    拥塞控制
    1.作用：
        防止过多的数据注入网络，可以使网络中的路由器或链路不至过载。

    拥塞控制是一个全局性的过程，涉及到所有主机、路由器、以及与降低网络传输性能有关的所有因素。

    2.拥塞控制方法：

    slow-start：慢开始
    congestion avoidance ：拥塞避免

    fast retransmit ：快重传
    fast recovery：快恢复
```


#### 9、DNS是什么（domain name system)
    域名系统，域名和IP相互映射
#### 10、DNS结构
```
    DNS结构设计为4层：根域、顶层域、第二层域、主机

    （1）根域：DNS的最上层，理论上只要是按照规定注册的域名，都能通过根域解析出来
    （2）顶层域： 比如com
    （3）第二层域：比如163
    （4）主机：各个域的管理员自行定义
```
